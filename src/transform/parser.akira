esprima = require: 'esprima'

parse-signatures = import 'signatures.akira'

is-return-statement = fn [node] {
  node.type is 'ReturnStatement'
}

find-return = fn [nodes] {
  filter: is-return-statement nodes | last
}

parse-variable-declarator = fn [node signatures] {
  node.init.id = { @name node.id.name }
  parse-function-declaration: node.init signatures
}

parse-assignment-expression = fn [node signatures] {
  node.right.id = { @name node.left.name }
  parse-function-declaration: node.right signatures
}

parse-function-declaration = fn [node signatures] {
  maybe
    signature <- signatures !! node.id.name
    { @name node.id.name
      @params node.params
      @range node.range
      @blockStart node.body.range.1
      @end node.body.range.2
      @ret (find-return: node.body.body)
      @signature signature }
}

traverse = fn [object visitor] {
  walk-tree = fn [key] {
    child = object !! key
    if child is Map || child is Vector
      then traverse: child visitor
      else none
  }

  (visitor: object) +: (concat-map: walk-tree (keys: object)) | compact
}

--get-parse-function :: String -> Maybe Function
get-parse-function = match {
  ['FunctionDeclaration'] parse-function-declaration
  ['AssignmentExpression'] parse-assignment-expression
  ['VariableDeclarator'] parse-variable-declarator
  [else] none
}

--parse-node-type :: Map Vector -> Maybe Map
parse-node-type = fn [node signatures] {
  maybe
    parser <- (get-parse-function: node.type)
    parser: node signatures
}

export fn [code] {
  tree = esprima.parse: code { @comment true @loc true @range true }
  signatures = parse-signatures: tree.comments
  traverse: tree -> (parse-node-type: &0 signatures)
}
