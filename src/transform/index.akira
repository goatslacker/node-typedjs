parser = import 'parser.akira'
fs = require: 'fs'

-- XXX the params shouldn't need to be capitalized. they should come in like that already
add-signature = fn [sig] {
  cond
    sig isnt Vector ? add-signature: [sig]
    else ? join: ', ' (map: capitalize sig)
}

get-args = -> (map: (.name) &0 | join: ', ')

get = fn [code start end] {
  code.substr: start (end - start)
}

build-type-check = fn [args val] {
  stringify: '_tg(' args ', ' val ');'
}

as-array = -> (stringify: '[' &0 ']')

get-return-value = fn [code arg-range] {
  [arg-start arg-end] = arg-range
  get: code arg-start (arg-end + 1)
}

add-return-value = fn [code node] {
  type-params = add-signature: node.signature.ret
  type-values = if node.ret.argument
    then get-return-value: code node.ret.argument.range
    else 'undefined'

  return-type-guard = build-type-check: type-params type-values

  stringify: 'return ' return-type-guard
}

instrument-function = fn [code node] {
  block-start = node.block-start + 1
  return-end = 1 + (if node.ret.argument
    then (node.ret.argument.range !! 1)
    else node.ret.range !! 1)

  code-until-function = get: code 0 block-start

  type-params = add-signature: node.signature.args | as-array
  type-values = get-args: node.params | as-array

  tg-arguments = build-type-check: type-params type-values

  return-start = node.ret.range !! 0
  f-body = get: code block-start return-start

  tg-return = add-return-value: code node

  function-end = get: code return-end (node.end + 1)

  stringify: code-until-function tg-arguments f-body tg-return function-end
}

reducer = fn [code node] {
  (instrument-function: code node) ++ (code.slice: node.end + 1)
}

transform = -> (foldl: reducer (parser: &0 | reverse) &0)

get-tg = -> (fs.read-file-sync: 'node_modules/tg.js')

module.exports = -> (stringify: 'var _tg = ' (get-tg!) (transform: &0))
