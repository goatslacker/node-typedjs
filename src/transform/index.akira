parser = import 'parser.akira'
fs = require: 'fs'

comma = ', '

get-args = -> (map: (.name) &0 | join: comma)

convert-signature = fn [x] {
  cond
    x is Map ? if x.or
      then stringify: 'tg.Or(' (join: comma x.or) ')'
      else stringify: 'tg.Maybe(' (x !! 'maybe') ')'
    x is Vector ? map: convert-signature x | join: comma
    else ? x
}

get = fn [code start end] {
  code.substr: start (end - start)
}

build-type-check = fn [args val] {
  stringify: 'tg(' args comma val ');'
}

as-array = -> (stringify: '[' &0 ']')

get-return-value = fn [code arg-range] {
  [arg-start arg-end] = arg-range
  get: code arg-start (arg-end + 1)
}

add-return-value = fn [code node] {
  type-params = convert-signature: node.signature.ret
  type-values = if node.ret.argument
    then get-return-value: code node.ret.argument.range
    else 'undefined'

  return-type-guard = build-type-check: type-params type-values

  stringify: 'return ' return-type-guard
}

get-return-end = fn [ret] {
  value = if ret.argument
    then ret.argument.range !! 1
    else ret.range !! 1
  value + 1
}

get-tg-arguments = fn [node] {
  type-params = convert-signature: node.signature.args | as-array
  type-values = get-args: node.params | as-array
  build-type-check: type-params type-values
}

instrument-function = fn [code node] {
  block-start = node.block-start + 1
  code-until-function = get: code 0 block-start

  tg-arguments = get-tg-arguments: node

  return-start = node.ret.range !! 0
  f-body = get: code block-start return-start

  tg-return = add-return-value: code node

  return-end = get-return-end: node.ret
  function-end = get: code return-end (node.end + 1)

  stringify: code-until-function tg-arguments f-body tg-return function-end
}

reducer = fn [code node] {
  (instrument-function: code node) ++ (code.slice: node.end + 1)
}

transform = -> (foldl: reducer (parser: &0 | reverse) &0)

get-tg = -> (fs.read-file-sync: 'node_modules/tg.js' | String)

module.exports = -> (stringify: (get-tg!) ';' (transform: &0))
